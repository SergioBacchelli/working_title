# BXF2 — минимальный профиль (панели + положение в пространстве)

Этот документ фиксирует **минимально необходимую** структуру и данные, чтобы:
1) описать панели (размеры),  
2) задать их положение/ориентацию в пространстве,  
3) и восстановить 3D‑модель корпуса.

Мы сознательно **не** вычисляем и **не** генерируем “производные” мебельные смыслы (вкладной/накладной, зазоры, внутренние размеры и т.п.).  
Если в BXF2 корректны `extent` и `transformations`, то **этого достаточно** для построения модели — остальное можно делать **только как опциональную валидацию**.

---

## 0) Подтверждение минимума (по факту)

Мы сравнили:

- `Original.bxf2` — исходник, который генерирует Blum
- `Cleared.bxf2` — очищенный вручную, **100% валидный** (проверено импортом)

**Факт:** `Cleared.bxf2` содержит ровно тот минимум, который нам нужен для проекта:
- панели: `parts/part` → `geometry(Box)/extent`
- положение: `cabinets/cabinet/partLinks/partLink/transformations`
- связь сцены и корпуса: `scene/.../cabinetLink referenceId`

**Убрано как “лишнее” (и всё равно работает):**
- `library/containers`
- `parts/part/material`
- `parts/part/drawingDetail` (не влияет на импорт модели; оставляем как опцию на будущее)
- значения параметров (`.../parameter/value`)
- `scene/.../cabinetLink/parameters` и `description` внутри `cabinetLink`
- `partLink/parameters`

> Ниже мы фиксируем “минимальный профиль Cleared” как **эталон** для генерации.

---

## 1) Что является «истиной» в BXF2 (для нашей задачи)

BXF2 описывает модель через два набора данных:

1) **Геометрия панели**  
   `library/parts/part/geometry` (`xsi:type="Box"`) + `extent`

2) **Положение панели**  
   `library/cabinets/cabinet/partLinks/partLink/transformations`  
   где каждая `transformation` — это `rotation` (axis‑angle) или `translation`.

Если эти данные корректны — **3D‑модель однозначно восстанавливается**.

---

## 2) Система координат

### 2.1 Глобальная система координат (корпус/сцена)
По реальным файлам BXF2 используем трактовку:

- **X**: слева → направо  
- **Y**: снизу → вверх  
- **Z**: сзади → вперёд (к фасаду)

Точка `(0,0,0)` в примерах соответствует левому‑нижнему‑заднему углу корпуса **в конкретной сцене** (это не “правило формата”, а принятая в примерах привязка).

### 2.2 Локальная система координат панели (part)
Панель хранится как `Box` и размеры задаются вдоль **локальных осей панели**:

- `extent = (Ex, Ey, Ez)` → **(sizeX, sizeY, sizeZ)** в мм  
- `|Ex| = sizeX`, `|Ey| = sizeY`, `|Ez| = sizeZ`
- **знак** `Ex/Ey/Ez` выбирает, от какого угла считать локальный `(0,0,0)` (коробка «растёт» в сторону знака).

### 2.3 «Длина/ширина» (мебельная терминология)
Мебельные “длина/ширина” — это **твои рабочие ярлыки** (про раскрой/текстуру), а не оси BXF2.

Чтобы не путать термины в правилах:
- в BXF2 используем **sizeX/sizeY/sizeZ**,
- мебельные размеры при необходимости храним как производные:
  - `longSide = max(sizeX, sizeY)`
  - `shortSide = min(sizeX, sizeY)`
- если нужна текстура/волокно — добавляем отдельный атрибут (например `grainAxis: "X"|"Y"`), но не выводим его из слов “длина/ширина”.

---

## 3) Минимальная структура XML (эталон = Cleared.bxf2)

Ниже — структура, которую мы считаем **минимально достаточной и валидной**.

### 3.1 Корень
Сохраняем namespace и schemaLocation как в `Cleared.bxf2` (для максимальной совместимости импортёров):

- `xmlns="http://www.blum.com/bxf2"`
- `xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"`
- `xmlns:ns2="http://www.blum.com/bxf2/bxf2snp"` *(не используется, но оставляем как в эталоне)*
- `xsi:schemaLocation="http://www.blum.com/BXF2 http://www.blum.com/BXF2/bxf2.xsd"`

### 3.2 head (минимум)
Оставляем элементы как в эталоне, значения могут быть пустыми:

- `version`
- `date`
- `author`
- `copyright`
- `unit` **обязательно** с атрибутами: `meter="0.001" name="mm"`
- `angularUnit` текст: `degree`
- `country`
- `language`
- `parameters` → `parameter name="..."` *(без `value` — как в Cleared)*

### 3.3 scene (минимум)
Достаточно одного узла и одной ссылки на cabinet:

- `scene/nodes/node/description` *(может быть пустой)*
- `scene/nodes/node/cabinetLinks/cabinetLink referenceId="CABINET_ID"`  
  *(без description/parameters)*

### 3.4 library (минимум)
Секции и порядок как в эталоне:

- пустые: `components`, `machiningGroups`, `machinings`, `cabinetGroups`, `functionUnits`, `articles`
- заполненные: `cabinets` и `parts`
- **не используем и не генерируем**: `containers` *(в Cleared отсутствует и всё работает)*

---

## 4) Минимальные данные о панели и её положении

### 4.1 Панель (library/parts/part)
Обязательные поля (минимально для импорта):

- `part @id` — уникальный ID
- `description` — имя панели
- `geometry xsi:type="Box"`
- `extent` — три числа (Ex Ey Ez), текстом внутри тега

Опционально (импорт проходит и без этого):
- `drawingDetail` с атрибутами:
  - `frontOrientation="x y z"`
  - `floorOrientation="x y z"`

> Примечание: `drawingDetail` описывает ориентацию (условно «лицо/пол») и может оказаться важным, когда перейдём к пазам/отверстиям. Сейчас для минимального корпуса можно не генерировать.

> Материал (`material`) не нужен для нашей задачи и в Cleared отсутствует.

### 4.2 Положение панели (library/cabinets/.../partLink)
Обязательные поля:

- `partLink @referenceId` → ссылка на `part @id`
- `transformations/transformation` — список операций:
  - `rotation="ax ay az angle"` *(axis‑angle, градусы)*
  - `translation="tx ty tz"` *(мм)*

Правило применения:
- трансформации применяются **последовательно в порядке записи**.
- В эталоне используется конвенция: сначала все `rotation`, затем один `translation`.


### 4.3 Как понимать отрицательные `extent` и “трансформации”

Это критично для входных параметров от логики: **мы не считаем зазоры**, мы просто описываем **размер** и **преобразование**.

#### 4.3.1 Геометрия `Box`
`geometry(Box)` задаётся одной точкой-началом и “вектором до противоположного угла”:

- локальный ноль панели: `O = (0,0,0)`
- противоположный угол: `E = (Ex, Ey, Ez)`

Отсюда диапазоны координат внутри панели:
- `x ∈ [min(0,Ex), max(0,Ex)]`
- `y ∈ [min(0,Ey), max(0,Ey)]`
- `z ∈ [min(0,Ez), max(0,Ez)]`

#### 4.3.2 Что означает отрицательный `Ex/Ey/Ez`
Если, например, `Ex < 0`, то панель “растёт” в отрицательную сторону локальной оси X.
Практический смысл: **выбор “якорного” угла панели**, который считается локальным `(0,0,0)`.

Это удобно, потому что все `rotation` в `transformations` выполняются **вокруг локального нуля**.
Меняя знак `extent`, можно выбирать опорный угол **без дополнительных смещений**.

#### 4.3.3 Как применяется `transformations`
Преобразования применяются **последовательно в порядке записи**.

Если есть несколько `rotation` и затем `translation`, то для любой точки панели `P_local`:

1) `P1 = R1(P_local)`
2) `P2 = R2(P1)`
3) ...
4) `P_global = Pn + T`

Где:
- `rotation="ax ay az angle"` — поворот вокруг оси `(ax,ay,az)` на `angle` градусов (правило правой руки),
- `translation="tx ty tz"` — перенос в координатах корпуса.

#### 4.3.4 Наблюдение по стилю файлов (не ограничение формата)
По примерам мы видим типичный паттерн: панель описывают “в базовой ориентации”, а затем ставят на место 0–2 поворотами (чаще всего кратными 90°), и финальным переносом.

Это **не гарантированное ограничение BXF2**, но хорошая практическая конвенция для генератора:
- допускаем `rotations: array` длины N,
- но стараемся держать N маленьким (0–2), если логике так проще.


---

## 5) Входные данные от логического модуля (контракт)

Нам нужно получать **ровно то**, что требуется для заполнения минимального профиля BXF2.

### 5.1 Минимальный контракт на панель (PanelExport)
Для каждой панели логический модуль должен отдать:

1) **Имя**  
   `name: string` → пойдёт в `part/description`

2) **Размеры в терминах BXF2**  
   Либо сразу `extent`:
   - `extent: [Ex, Ey, Ez]` (мм, допускаются дробные; знак важен)

   Либо (если модулю удобнее) раздельно:
   - `sizeX, sizeY, sizeZ` (положительные)
   - `extentSigns: [sx, sy, sz]` где каждый `sx ∈ {+1,-1}`  
     и итог: `Ex = sx*sizeX` и т.д.

3) **Положение в пространстве (в координатах корпуса)**  
   Самый прямой формат (1:1 к BXF2):
   - `rotations: array` где каждая запись = `{axis:[ax,ay,az], deg:number}`
   - `translation: [tx,ty,tz]`

4) **drawingDetail (опционально)**
   Сейчас можно не выдавать и не генерировать — импорт проходит без него (проверено).
   Оставляем на будущее: возможно понадобится для `machinings` (пазы/отверстия) из‑за понятия лицевой стороны.

   Если используем:
   - `frontOrientation: [x,y,z]`
   - `floorOrientation: [x,y,z]`


### 5.2 Контракт на корпус (CabinetExport)
- `cabinetId` *(можно генерировать автоматически)*
- `cabinetName` *(опционально; `cabinet/description`)*
- `panels: PanelExport[]`

### 5.3 Правила генерации ID
Если логический модуль не выдаёт ID, экспортёр генерирует:
- `cabinetId = ID00001`
- панели: `ID00002`, `ID00004`, ... (любой уникальный набор)
- `partLink.referenceId` всегда должен совпадать с `part.id`.

---


### 5.4 Алгоритм: 6 ориентаций (VL/VR/HT/HB/FR/RR) → знаки `extent`, повороты и смещения

Эта часть описывает **детерминированный** способ генерировать BXF2 “как делает Blum” (по стилю `Cleared.bxf2`):
- у панели есть **Box/extent** (3 числа, знак важен),
- у `partLink` есть **0–2 поворота** на кратные 90° и **одно смещение (translation)**,
- панели в сцене **осе-ориентированные** (параллельны граням куба).

#### 5.4.1 Вход от логического модуля (минимум для сотен панелей)

Для каждой панели логический модуль должен вернуть **не «длина/ширина», а геометрию в координатах корпуса**:

- `bboxMin = (x0, y0, z0)` — минимальный угол панели в глобальных осях
- `bboxMax = (x1, y1, z1)` — максимальный угол панели в глобальных осях
- `side` — одна из 6 ориентаций: `VL`, `VR`, `HT`, `HB`, `FR`, `RR`

Где `(x0<x1, y0<y1, z0<z1)`.  
Этого достаточно, чтобы однозначно вычислить:
- размеры `dx=x1-x0`, `dy=y1-y0`, `dz=z1-z0`,
- якорную точку `translation`,
- знаки `extent` и 0–2 поворота.

> Почему bbox удобнее: в сцене может быть 100+ панелей, но каждая всё равно в итоге занимает прямоугольный параллелепипед в глобальных осях.

#### 5.4.2 Повороты (ровно как в `Cleared.bxf2`)

Используем фиксированные осевые повороты:

- `ROT_X = (1 0 0 -90)`
- `ROT_Z_N = (0 0 1 -90)`
- `ROT_Z_P = (0 0 1 90)`
- `ROT_Z_180 = (0 0 1 180)`
- `ROT_Y_180 = (0 1 0 180)`

Для “корпусных” панелей (`VL/VR/HT/HB`) почти всегда достаточно `ROT_X` + (иногда) один `ROT_Z_*`.
Для “фасадных” (`FR`) у Blum часто встречается `ROT_Y_180`.

#### 5.4.3 Таблица: ориентация → `extent` + `transformations`

Обозначения:
- `dx = x1-x0` (размер по X)
- `dy = y1-y0` (размер по Y)
- `dz = z1-z0` (размер по Z)
- `T(x,y,z)` — translation (смещение)

**HB — Horizontal Bottom (нижняя горизонтальная)**
- `extent = ( +dx, +dz, +dy )`
- `transformations = [ ROT_X,  T(x0, y0, z1) ]`

**HT — Horizontal Top (верхняя горизонтальная)**
- `extent = ( -dx, +dz, +dy )`
- `transformations = [ ROT_X, ROT_Z_180, T(x0, y1, z1) ]`

**VL — Vertical Left (левая вертикальная)**
- `extent = ( -dy, +dz, +dx )`
- `transformations = [ ROT_X, ROT_Z_N, T(x0, y0, z1) ]`

**VR — Vertical Right (правая вертикальная)**
- `extent = ( +dy, +dz, +dx )`
- `transformations = [ ROT_X, ROT_Z_P, T(x1, y0, z1) ]`

**FR — Front (передняя)**
- `extent = ( +dx, +dy, +dz )`
- `transformations = [ ROT_Y_180, T(x1, y0, z1) ]`

**RR — Rear (задняя)**
В эталоне `Cleared.bxf2` задней стенки нет, поэтому здесь фиксируем **минимально-рабочую конвенцию** (подтвердим на примере с RR):
- `extent = ( +dx, +dy, +dz )`
- `transformations = [ T(x0, y0, z0) ]`

> Важно: для `VL/VR/HT/HB/FR` эта таблица **в точности воспроизводит стиль Blum** на проверенных файлах (включая отрицательные `extent` и выбор якорных углов).

#### 5.4.4 Почему здесь появляются «минусы» (и почему это хорошо)

Минус в `extent` — это не “отрицательный размер”, а способ выбрать **якорный угол** панели так, чтобы:
- поворотов было максимум 2,
- `translation` получался “красивым” (часто использует `x0/x1`, `y0/y1`, `z1`),
- панель после трансформаций попадала в нужный bbox без дополнительных вычислений.

Практически: знак в `extent` выбирается так, чтобы после поворотов панель “уходила” в нужную сторону **от выбранного якоря**.

#### 5.4.5 Какие данные нужны для смещений (короткий ответ)

Если панель осе-ориентированная (6 граней куба), то для `translation` всегда достаточно:
- **трёх координат якорной точки**: `Tx,Ty,Tz`.

А чтобы их получить без гаданий — логический модуль должен уметь считать **bboxMin/bboxMax** панели в координатах корпуса.


## 6) Что НЕ требуется от логического модуля
Чтобы не раздувать сложность, **не просим** у логики:

- зазоры фасада
- вкладной/накладной
- вычисление bbox/габаритов корпуса
- параметры раскроя/текстуры (если понадобится — добавим отдельно)
- материал
- контейнеры/группы/прочие разделы библиотек

---

## 7) Когда появятся отверстия/пазы
Отверстия/пазы — это следующий уровень. Для них нужен отдельный минимальный профиль, где обработки привязаны к панели и заданы в локальных координатах панели.

Пока в наших примерах обработок нет — правила не придумываем, добавим после следующего файла‑образца.

---

## 8) Опциональная валидация (если захочешь)
BBox/зазоры/“вкладной‑накладной” — это **вычисляемые следствия**.
Их можно считать только для контроля корректности (поймать ошибку знака `extent`, порядка `rotation`, смещения),
но **не** как обязательные данные для генерации BXF2.


---

## Алгоритм позиционирования (смещение / translation) в стиле Blum

Цель: получать **валидный BXF2**, не вычисляя “мебельные смыслы” (вкладной/накладной, зазоры и т.п.).
Логический модуль должен отдавать **геометрию в координатах корпуса**, а мы переводим её в набор:
`extent (со знаками) + rotations (0..2) + translation`.

### 1) Вход логического модуля

Минимально устойчивый вход на каждую панель:

- `side`: `VL | VR | HT | HB | FR | RR`
- `bboxMin = (x0, y0, z0)` и `bboxMax = (x1, y1, z1)` в координатах корпуса  
  (оси корпуса: X→вправо, Y→вверх, Z→к фасаду)

Из bbox автоматически получаем “размеры вдоль осей корпуса”:
- `dx = x1 - x0`
- `dy = y1 - y0`
- `dz = z1 - z0`

> Это лучший формат именно для “смещений”: он не зависит от того, как ты называешь длину/ширину,
> и одинаково работает для вкладных/накладных/внутренних деталей — логика просто меняет bbox.

### 2) Почему translation часто берётся как (… , … , z1)

В наших “Blum-ориентациях” большинство корпусных панелей используют `ROT_X = (1 0 0 -90)`.
После такого поворота локальная ось **+Y** превращается в глобальную **-Z**.
Значит, если `extent.Y` положительный (глубина), деталь “растёт” **в минус Z**.
Чтобы она легла в диапазон `z0…z1`, Blum ставит `translation.z = z1` (т.е. на “передний” край),
а сама геометрия уходит назад до `z0`.

Это объясняет и “неочевидные” смещения, и то, почему отрицательные значения в `extent`
используются как **выбор якорного угла**, а не как «минус‑размер».

### 3) Смещение как выбор «якорного угла bbox»

В стиле Blum `translation` почти всегда равен одному из 8 углов bbox панели.
Для наших 6 сторонностей — вот детерминированное правило:

- `VL`  → `translation = (x0, y0, z1)`
- `VR`  → `translation = (x1, y0, z1)`
- `HB`  → `translation = (x0, y0, z1)`
- `HT`  → `translation = (x0, y1, z1)`
- `FR`  → `translation = (x1, y0, z1)`
- `RR`  → `translation = (x0, y0, z0)` **(пока гипотеза, подтвердим на примере с задней стенкой)**

Важно: это правило работает **вместе** с фиксированными rotations и выбранными знаками extent (таблица выше).
Если поменять rotations/знаки — “правильный угол bbox” для translation тоже поменяется.

### 4) Итоговый алгоритм (без математики матриц)

Для каждой панели:

1) Возьми `side`, `bboxMin (x0,y0,z0)` и `bboxMax (x1,y1,z1)`.
2) Посчитай `dx, dy, dz`.
3) По `side` выбери:
   - `rotations` (0..2)
   - формулу `extent` (со знаками)
   - формулу `translation` (угол bbox)
4) Запиши в BXF2:
   - `library/parts/part/geometry(Box)/extent = "Ex Ey Ez"`
   - `library/cabinets/.../partLink/transformations`:
     1..N `rotation`, затем 1 `translation`

### 5) Что это даёт логическому модулю

Логический модуль больше не думает про “Blum-магии”:
- он просто выдаёт **где деталь находится в корпусе** (`bbox`) и какую сторону она представляет (`side`);
- а экспортный модуль превращает это в **стабильный** `extent+transformations`.

При сотнях деталей это критично: вариантов ориентации всего 6, а смещения — это всегда выбор угла bbox.
