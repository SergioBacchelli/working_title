# ARCHITECTURE — общая архитектура проекта `working title`

## 1. Назначение проекта

Проект `working title` — учебно-рабочий проект для отработки:

- архитектуры (слои, модули, хранилище данных);
- документации (карта, решения, workflow);
- рабочего процесса с Git и ChatGPT (Рэй).

Основной сценарий:
- существуют логические модули, которые принимают входные данные;
- каждый модуль вычисляет некоторый результат (набор полей);
- результаты нужно сохранять во внешнее хранилище (не браузер).

---

## 2. Слои архитектуры

Проект разделён на несколько слоёв:

### 2.1. UI (client)

- Отвечает за взаимодействие с пользователем:
  - формы ввода,
  - отображение результатов,
  - навигация по экрану.
- Не знает деталей хранения данных и реализации логики:
  - вызывает только публичные интерфейсы Application/Core (например, “запустить модуль”, “получить результат модуля”).

*(Конкретная технология UI будет выбрана позже и зафиксирована отдельным решением.)*

---

### 2.2. Application / Core (Logic)

- Содержит бизнес-логику проекта:
  - определяет интерфейсы логических модулей;
  - управляет их вызовом;
  - отвечает за валидацию входных данных и формирование результата.
- Работает с данными только через слой `Storage`:
  - не знает, используется ли файлы, SQLite, MySQL или что-то ещё;
  - видит абстракции вида:
    - `saveResult(moduleId, data)`
    - `loadResult(moduleId)`
    - и т.п. (конкретный интерфейс будет описан позже).

---

### 2.3. Storage (хранилище данных)

Слой `Storage` отвечает за сохранение и загрузку данных логических модулей.

Общие принципы:

- Core обращается к Storage через чёткий интерфейс (контракты будут описаны отдельно).
- Storage скрывает от Core детали реализации:
  - где лежат файлы,
  - в каком формате они записаны,
  - будет ли в будущем использоваться база данных.

**Текущая реализация (Phase 1): файловое хранилище**

- Для хранения результатов используется файловое хранилище на стороне сервера.
- Один логический модуль → **один файл** с данными.
- Имя файла задаётся одним из полей интерфейса логического модуля (идентификатор/имя файла):
  - если имя совпадает с уже существующим файлом — файл полностью перезаписывается;
  - если имя новое — создаётся новый файл.
- Для файлов с данными используется отдельная папка (например, `data/` внутри проекта):
  - структура и название папки будут уточнены в отдельном решении и карте проекта.
- История изменений внутри самих файлов **не хранится**:
  - каждый запуск модульной логики перезаписывает файл целиком;
  - логика версионности при необходимости будет реализована в другом слое или в будущей реализации хранилища.

**Формат файла данных логического модуля**

- Каждый логический модуль сериализуется в текстовый файл.
- Каждая строка файла соответствует **одному полю** данных.
- Формат строки:

<FieldKeyEn>(Display:<FieldNameRuNoSpaces>)<Value>

markdown
Копировать код

- `FieldKeyEn` — ключ поля по-английски (идентификатор поля);
- `FieldNameRuNoSpaces` — русское название поля **без пробелов**, обёрнутое в префикс `Display:` (например, `ВысотаФасада`, `ЦветКорпуса`);
- `Value` — значение поля;
- во всей строке **нет пробелов**, разделитель — символ `_`.

- Пример условной строки:

height_(Display:ВысотаФасада)720
color(Display:ЦветФасада)_White

markdown
Копировать код

- Конкретный список полей и их ключей/отображаемых имён будет определяться логическим модулем и зафиксирован в отдельной документации по модулям.

**Будущие реализации (Phase 2 и далее)**

- В будущем возможно заменить файловое хранилище на базу данных (например, SQLite / MySQL / Postgres).
- При этом:
- интерфейс `Storage` для Core должен остаться тем же (или минимально измениться);
- переход на БД оформляется отдельным решением в `DECISIONS.md` и изменениями в этом файле.

---

### 2.4. Infrastructure (server)

- Отвечает за интеграцию с “наружным миром”:
- HTTP API, которые вызывают логические модули;
- доступ к файловой системе (реализация файлового `Storage`);
- подключение к БД (в будущих версиях);
- интеграции с внешними сервисами (например, Google Sheets) — при необходимости.
- Не содержит бизнес-логики, а только реализует технические детали:
- маршрутизация запросов;
- вызов Core;
- обработка ошибок на уровне транспорта и окружения.

---

## 3. Связь между слоями

- UI (client) взаимодействует только с Application/Core через публичные интерфейсы.
- Application/Core:
- реализует сценарии;
- вызывает логические модули;
- для сохранения/загрузки данных обращается к `Storage`.
- Storage:
- в текущей реализации работает с файловой системой (Phase 1);
- в будущем может использовать БД, не меняя внешний интерфейс для Core.
- Infrastructure:
- предоставляет Core окружение (запуск, HTTP, файловая система, БД);
- не решает бизнес-задач.

---

## 4. Открытые вопросы

Следующие вопросы остаются открытыми и будут решены в отдельных решениях (`DECISIONS.md`):

1. Конкретный интерфейс модуля `Storage`:
 - названия методов (например, `saveModuleData`, `loadModuleData`),
 - сигнатуры (какие поля принимает, что возвращает),
 - формат ошибок.

2. Конкретный формат данных логического модуля:
 - полный перечень полей,
 - соглашения по именам `FieldKeyEn`,
 - правила формирования `FieldNameRuNoSpaces`.

3. Точное расположение и имя папки для файлов:
 - например, `data/` в корне проекта или `data/` внутри `src/server/`.

4. Требования к многопользовательскому режиму:
 - будут ли разные пользователи иметь отдельные наборы файлов;
 - нужна ли авторизация/изоляция данных между пользователями.

Все ответы на эти вопросы будут оформляться в `DECISIONS.md` и, при необходимости, отражаться